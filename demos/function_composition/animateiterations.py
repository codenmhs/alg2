'''9/28/21 by Wyatt Homola

This program addresses a student complaint that function composition, and I quote, "sucks."  It demonstrates the bifurcation diagram as 
generated by the iteration of a quadratic function x1 = x0 ** 2 + c for different values of c. 
'''
import matplotlib.pyplot as plt
from matplotlib import animation
import numpy as np

# How many iterations
count = 1000
# Animation frame rate in ms
rate = 10

def getiterations(c, initial, count): 

    '''Get count iterations of the recursive formula x1 = x0 ** 2 + c with starting x value of initial
    
        1) Start at the coordinates (initial, 0).  
        2) On the first iteration, reach point (initial, f(initial))
        3) For demonstration purpose, travel over to the line y = x to show that the output value becomes the next input value: reach point (f(initial), f(initial))
        4) Reach the next iteration, (f(x), f(f(x)), repeating step 2, then repeat step 3.
        
        So after count iterations, there are count coordinates in the list which lie on the parabola, count coordinates on the line y = x, and a single 
        initial coordinate on the x axis.
        Thus, in total this function generates 2 * count + 1 coordinate pairs. 
    '''
   
    coordinates = np.array([[initial, 0]])
    for i in range(count): 
        # Numpy slicing syntax for "the y second value of the last coordinate pair"
        x_new = coordinates[-1:, 1][0]
        y_new = (x_new ** 2) + c
        # Append the new point which lies on the parabola
        coordinates = np.concatenate((coordinates, [[x_new, y_new]]), axis=0)
        # Append the new point which lies on y = x
        coordinates = np.concatenate((coordinates, [[y_new, y_new]]), axis=0)
        
    return coordinates

c = [-1.4015, -3 / 4, -1.3, -1.8]

# Get the x and y coordinates for the trajectories
coordinates = [getiterations(q, 0, count) for q in c]
# Get x coordinates for the parabolas and lines
parabola_x = np.arange(-2, 2, 0.1)
parabola_y = [[i**2 + q for i in parabola_x] for q in c]

nrows = 2
ncols = 2
fig, ax = plt.subplots(nrows, ncols)
traj1, = ax[0, 0].plot([], [], lw=1)
traj2, = ax[0, 1].plot([], [], lw=1)
traj3, = ax[1, 0].plot([], [], lw=1)
traj4, = ax[1, 1].plot([], [], lw=1)
ax[0, 0].set_title('c = -1.4015')
ax[0, 1].set_title('c = -3/4')
ax[1, 0].set_title('c = -1.3')
ax[1, 1].set_title('c = -1.8')

def init(): 
    for traj in [traj1, traj2, traj3, traj4]: 
        traj.set_data([], [])
    return traj1, traj2, traj3, traj4

def animate(k): 
    traj = [[traj1, traj2], [traj3, traj4]]
    count = 0 
    for i in range(nrows): 
        for j in range(ncols): 
            traj[i][j].set_data(coordinates[count][:, 0][:k], coordinates[count][:, 1][:k])
            ax[i, j].plot(parabola_x, parabola_y[count], label="parabola")
            ax[i, j].plot(parabola_x, parabola_x, label="line")
            count += 1
    return traj1, traj2, traj3, traj4
# ax.plot(np.arange(-1, 1, 0.1), np.square(np.arange(-1, 1, 0.1)), label="parabola")

anim = animation.FuncAnimation(fig, animate, init_func=init, frames=200, interval=rate, blit=True)

plt.show()